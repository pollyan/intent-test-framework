<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰§è¡Œæ§åˆ¶å° - AIæµ‹è¯•ç³»ç»Ÿ</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f0f2f5;
        }

        .header {
            background: white;
            padding: 16px 24px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .header h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }

        .back-btn {
            color: #1890ff;
            text-decoration: none;
            padding: 8px 16px;
            border: 1px solid #1890ff;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: #1890ff;
            color: white;
        }

        .content {
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            height: calc(100vh - 120px);
        }

        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 16px 24px;
            border-bottom: 1px solid #f0f0f0;
            font-weight: 600;
            font-size: 16px;
        }

        .panel-content {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .testcase-selector {
            margin-bottom: 20px;
        }

        .testcase-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .testcase-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d9d9d9;
            border-radius: 4px;
            font-size: 14px;
        }

        .execution-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .mode-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 20px;
        }

        .mode-selector label {
            font-weight: 500;
        }

        .mode-selector input[type="radio"] {
            margin-right: 4px;
        }

        .execution-type-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .execution-type-selector label {
            font-weight: 500;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .execution-type-selector label:hover {
            background-color: #f0f0f0;
        }

        .execution-type-selector input[type="radio"] {
            margin-right: 4px;
        }

        .bridge-status {
            margin: 15px 0;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            background-color: #f8f9fa;
        }

        .bridge-status h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #24292e;
        }

        .status-content {
            font-size: 13px;
            color: #586069;
        }

        .status-available {
            color: #28a745;
            font-weight: 500;
        }

        .status-unavailable {
            color: #d73a49;
            font-weight: 500;
        }

        .install-guide-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background-color: #0366d6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .install-guide-btn:hover {
            background-color: #0256cc;
        }

        .refresh-status-btn {
            margin-left: 8px;
            padding: 2px 6px;
            background-color: #f8f9fa;
            color: #586069;
            border: 1px solid #d1d5da;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .refresh-status-btn:hover {
            background-color: #e1e4e8;
        }

        .manual-confirm-area {
            margin-top: 12px;
            padding: 12px;
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
        }

        .manual-confirm-area h5 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #856404;
        }

        .manual-confirm-area label {
            display: block;
            margin: 6px 0;
            font-size: 12px;
            color: #856404;
            cursor: pointer;
        }

        .manual-confirm-btn, .confirm-status-btn {
            margin-top: 8px;
            margin-right: 8px;
            padding: 6px 12px;
            background-color: #ffc107;
            color: #212529;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .manual-confirm-btn:hover, .confirm-status-btn:hover {
            background-color: #e0a800;
        }

        .mode-description {
            margin-bottom: 20px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #007bff;
        }

        .mode-description small {
            color: #666;
            font-size: 13px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #52c41a;
            color: white;
        }

        .btn-primary:hover {
            background: #73d13d;
        }

        .btn-primary:disabled {
            background: #d9d9d9;
            cursor: not-allowed;
        }

        .btn-danger {
            background: #ff4d4f;
            color: white;
        }

        .btn-danger:hover {
            background: #ff7875;
        }

        .execution-status {
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status-idle {
            background: #f6ffed;
            border: 1px solid #b7eb8f;
            color: #389e0d;
        }

        .status-running {
            background: #e6f7ff;
            border: 1px solid #91d5ff;
            color: #1890ff;
        }

        .status-success {
            background: #f6ffed;
            border: 1px solid #b7eb8f;
            color: #52c41a;
        }

        .status-failed {
            background: #fff2f0;
            border: 1px solid #ffccc7;
            color: #ff4d4f;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-fill {
            height: 100%;
            background: #1890ff;
            transition: width 0.3s ease;
        }

        .step-list {
            margin-top: 20px;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .step-item:last-child {
            border-bottom: none;
        }

        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .step-icon.pending {
            background: #f0f0f0;
            color: #8c8c8c;
        }

        .step-icon.running {
            background: #1890ff;
            color: white;
            animation: pulse 1.5s infinite;
        }

        .step-icon.success {
            background: #52c41a;
            color: white;
        }

        .step-icon.failed {
            background: #ff4d4f;
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .step-description {
            color: #666;
            font-size: 13px;
            line-height: 1.4;
        }

        .step-time {
            color: #8c8c8c;
            font-size: 12px;
            margin-top: 4px;
        }

        .log-container {
            background: #001529;
            color: #fff;
            padding: 16px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 4px;
        }

        .log-timestamp {
            color: #8c8c8c;
            margin-right: 8px;
        }

        .log-level-info {
            color: #1890ff;
        }

        .log-level-success {
            color: #52c41a;
        }

        .log-level-error {
            color: #ff4d4f;
        }

        .log-level-warning {
            color: #fa8c16;
        }

        .screenshot-container {
            margin-top: 16px;
        }

        .screenshot-container img {
            max-width: 100%;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* æ­¥éª¤æˆªå›¾ç¼©ç•¥å›¾æ ·å¼ */
        .step-screenshot {
            margin-top: 8px;
            margin-bottom: 8px;
        }

        .step-screenshot-thumbnail {
            width: 120px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            border: 2px solid #e8e8e8;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .step-screenshot-thumbnail:hover {
            border-color: #1890ff;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .step-screenshot-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            text-align: center;
        }

        /* æˆªå›¾å†å²æ ·å¼ */
        .screenshot-history-container {
            margin-top: 20px;
        }

        .screenshot-history {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            background: #fafafa;
        }

        .screenshot-item {
            position: relative;
            width: 120px;
            height: 90px;
            border: 2px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .screenshot-item:hover {
            border-color: #1890ff;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .screenshot-item.current {
            border-color: #52c41a;
            box-shadow: 0 0 0 2px rgba(82, 196, 26, 0.2);
        }

        .screenshot-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .screenshot-item .step-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 4px;
            font-size: 10px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .screenshot-item .step-index {
            position: absolute;
            top: 2px;
            left: 2px;
            background: #1890ff;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        /* å…¨å±æˆªå›¾æŸ¥çœ‹å™¨ */
        .screenshot-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }

        .screenshot-viewer img {
            max-width: 95%;
            max-height: 95%;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        .screenshot-viewer-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
        }

        .screenshot-viewer-close:hover {
            color: #ccc;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #8c8c8c;
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>æ‰§è¡Œæ§åˆ¶å°</h1>
        <a href="/" class="back-btn">è¿”å›é¦–é¡µ</a>
    </div>

    <div class="content">
        <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
        <div class="panel">
            <div class="panel-header">æ‰§è¡Œæ§åˆ¶</div>
            <div class="panel-content">
                <!-- æµ‹è¯•ç”¨ä¾‹é€‰æ‹© -->
                <div class="testcase-selector">
                    <label for="testcaseSelect">é€‰æ‹©æµ‹è¯•ç”¨ä¾‹:</label>
                    <select id="testcaseSelect" class="testcase-select">
                        <option value="">è¯·é€‰æ‹©æµ‹è¯•ç”¨ä¾‹</option>
                    </select>
                </div>

                <!-- æ‰§è¡Œç±»å‹ -->
                <div class="execution-type-selector">
                    <label>æ‰§è¡Œç±»å‹:</label>
                    <label><input type="radio" name="execution_type" value="auto" checked> ğŸ¤– æ™ºèƒ½é€‰æ‹©</label>
                    <label><input type="radio" name="execution_type" value="local-proxy"> ğŸ–¥ï¸ æœ¬åœ°ä»£ç† <span id="localProxyStatus" class="badge bg-secondary">æ£€æµ‹ä¸­...</span></label>
                    <label><input type="radio" name="execution_type" value="bridge"> ğŸŒ‰ Chromeæ¡¥æ¥</label>
                    <label><input type="radio" name="execution_type" value="cloud"> â˜ï¸ äº‘ç«¯æ‰§è¡Œ</label>
                    <label><input type="radio" name="execution_type" value="local"> ğŸ  æœ¬åœ°æ‰§è¡Œ</label>
                </div>

                <!-- æ‰§è¡Œæ¨¡å¼ -->
                <div class="mode-selector">
                    <label>æ‰§è¡Œæ¨¡å¼:</label>
                    <label><input type="radio" name="mode" value="headless" checked> ğŸš€ æ— å¤´æ¨¡å¼</label>
                    <label><input type="radio" name="mode" value="browser"> ğŸ–¥ï¸ æµè§ˆå™¨æ¨¡å¼</label>
                </div>

                <!-- æ¡¥æ¥çŠ¶æ€æ˜¾ç¤º -->
                <div id="bridgeStatus" class="bridge-status" style="display: none;">
                    <h4>ğŸŒ‰ Chromeæ¡¥æ¥çŠ¶æ€: <button id="refreshStatusBtn" class="refresh-status-btn">ğŸ”„ åˆ·æ–°çŠ¶æ€</button></h4>
                    <div id="bridgeStatusContent" class="status-content"></div>

                    <!-- æ‰‹åŠ¨ç¡®è®¤åŒºåŸŸ -->
                    <div id="manualConfirmArea" class="manual-confirm-area" style="display: none;">
                        <h5>æ‰‹åŠ¨ç¡®è®¤çŠ¶æ€:</h5>
                        <label><input type="checkbox" id="confirmChrome"> âœ… æˆ‘ç¡®è®¤Chromeæµè§ˆå™¨æ­£åœ¨è¿è¡Œ</label><br>
                        <label><input type="checkbox" id="confirmExtension"> âœ… æˆ‘ç¡®è®¤å·²å®‰è£…MidSceneJS Chromeæ‰©å±•</label><br>
                        <label><input type="checkbox" id="confirmAI"> âœ… æˆ‘ç¡®è®¤å·²åœ¨æ‰©å±•ä¸­é…ç½®AI APIå¯†é’¥</label><br>
                        <button id="confirmStatusBtn" class="confirm-status-btn">ç¡®è®¤çŠ¶æ€</button>
                    </div>

                    <button id="installGuideBtn" class="install-guide-btn" style="display: none;">æŸ¥çœ‹å®‰è£…æŒ‡å—</button>
                    <button id="manualConfirmBtn" class="manual-confirm-btn">æ‰‹åŠ¨ç¡®è®¤çŠ¶æ€</button>
                </div>

                <!-- æ¨¡å¼è¯´æ˜ -->
                <div class="mode-description">
                    <small id="modeDescription">
                        ğŸ¤– <strong>æ™ºèƒ½é€‰æ‹©</strong>: è‡ªåŠ¨é€‰æ‹©æœ€ä½³æ‰§è¡Œæ–¹å¼
                    </small>
                </div>

                <!-- æ‰§è¡Œæ§åˆ¶æŒ‰é’® -->
                <div class="execution-controls">
                    <button id="startBtn" class="btn btn-primary" onclick="startExecution()">â–¶ï¸ å¼€å§‹æ‰§è¡Œ</button>
                    <button id="stopBtn" class="btn btn-danger" onclick="stopExecution()" disabled>â¹ï¸ åœæ­¢æ‰§è¡Œ</button>
                </div>

                <!-- æ‰§è¡ŒçŠ¶æ€ -->
                <div id="executionStatus" class="execution-status status-idle">
                    çŠ¶æ€: å°±ç»ª
                </div>

                <!-- è¿›åº¦æ¡ -->
                <div id="progressContainer" style="display: none;">
                    <div>æ‰§è¡Œè¿›åº¦:</div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div id="progressText">0 / 0</div>
                </div>

                <!-- æ­¥éª¤åˆ—è¡¨ -->
                <div id="stepList" class="step-list">
                    <div class="empty-state">
                        <div class="icon">ğŸ“</div>
                        <div>è¯·é€‰æ‹©æµ‹è¯•ç”¨ä¾‹æŸ¥çœ‹æ‰§è¡Œæ­¥éª¤</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å³ä¾§ç›‘æ§é¢æ¿ -->
        <div class="panel">
            <div class="panel-header">æ‰§è¡Œç›‘æ§</div>
            <div class="panel-content">
                <!-- å®æ—¶æ—¥å¿— -->
                <div>
                    <h4>æ‰§è¡Œæ—¥å¿—:</h4>
                    <div id="logContainer" class="log-container">
                        <div class="log-entry">
                            <span class="log-timestamp">[ç­‰å¾…ä¸­]</span>
                            <span class="log-level-info">ç³»ç»Ÿå°±ç»ªï¼Œç­‰å¾…æ‰§è¡ŒæŒ‡ä»¤...</span>
                        </div>
                    </div>
                </div>

                <!-- æˆªå›¾å±•ç¤º -->
                <div id="screenshotContainer" class="screenshot-container" style="display: none;">
                    <h4>å½“å‰æˆªå›¾:</h4>
                    <img id="currentScreenshot" src="" alt="æ‰§è¡Œæˆªå›¾">
                </div>

                <!-- æ­¥éª¤æˆªå›¾å†å² -->
                <div id="screenshotHistoryContainer" class="screenshot-history-container" style="display: none;">
                    <h4>æ­¥éª¤æˆªå›¾å†å²:</h4>
                    <div id="screenshotHistory" class="screenshot-history">
                        <!-- æˆªå›¾ç¼©ç•¥å›¾å°†åœ¨è¿™é‡ŒåŠ¨æ€æ·»åŠ  -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdn.socket.io/4.7.0/socket.io.min.js"></script>
    <script>
        // å…¨å±€å˜é‡
        const API_BASE = '/api';
        const LOCAL_PROXY_URL = 'http://localhost:3001';
        let currentExecution = null;
        let pollingInterval = null;
        let localProxySocket = null;
        let localProxyConnected = false;
        let testcases = [];
        let screenshotHistory = []; // å­˜å‚¨æ‰€æœ‰æ­¥éª¤çš„æˆªå›¾å†å²

        // é¡µé¢åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadTestcases();
            setupEventListeners();
            setupExecutionTypeListeners();
            checkBridgeStatus();

            // åˆå§‹åŒ–æœ¬åœ°ä»£ç†è¿æ¥
            checkLocalProxyConnection();
            connectLocalProxyWebSocket();

            // å®šæœŸæ£€æŸ¥æœ¬åœ°ä»£ç†è¿æ¥çŠ¶æ€
            setInterval(checkLocalProxyConnection, 30000);

            addLog('æ‰§è¡Œæ§åˆ¶å°å·²å°±ç»ª', 'success');
        });

        function setupEventListeners() {
            // æµ‹è¯•ç”¨ä¾‹é€‰æ‹©å˜åŒ–
            document.getElementById('testcaseSelect').addEventListener('change', function() {
                const testcaseId = this.value;
                if (testcaseId) {
                    loadTestcaseSteps(testcaseId);
                } else {
                    clearStepList();
                }
            });

            // URLå‚æ•°å¤„ç†
            const urlParams = new URLSearchParams(window.location.search);
            const testcaseId = urlParams.get('testcase');
            if (testcaseId) {
                setTimeout(() => {
                    document.getElementById('testcaseSelect').value = testcaseId;
                    loadTestcaseSteps(testcaseId);
                }, 1000);
            }
        }

        // è½®è¯¢æ£€æŸ¥æ‰§è¡ŒçŠ¶æ€
        function startPolling(executionId) {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }

            pollingInterval = setInterval(async () => {
                try {
                    const response = await axios.get(`${API_BASE}/executions/${executionId}/status`);
                    if (response.data.code === 200) {
                        const status = response.data.data;
                        updateExecutionFromStatus(status);

                        // å¦‚æœæ‰§è¡Œå®Œæˆï¼Œåœæ­¢è½®è¯¢
                        if (status.status === 'completed' || status.status === 'failed') {
                            clearInterval(pollingInterval);
                            pollingInterval = null;
                        }
                    }
                } catch (error) {
                    console.error('è½®è¯¢æ‰§è¡ŒçŠ¶æ€å¤±è´¥:', error);
                }
            }, 1000); // æ¯ç§’è½®è¯¢ä¸€æ¬¡
        }

        function updateExecutionFromStatus(status) {
            // æ›´æ–°æ‰§è¡ŒçŠ¶æ€
            updateExecutionStatus(status.status, status.message || '');

            // æ›´æ–°æ­¥éª¤çŠ¶æ€
            if (status.steps) {
                status.steps.forEach((step, index) => {
                    updateStepStatus(index, step.status);
                });
                updateProgress(status.completed_steps || 0, status.total_steps || 0);
            }

            // æ·»åŠ æ—¥å¿—
            if (status.current_step) {
                addLog(`å½“å‰æ­¥éª¤: ${status.current_step}`, 'info');
            }
        }

        async function loadTestcases() {
            try {
                console.log('å¼€å§‹åŠ è½½æµ‹è¯•ç”¨ä¾‹...');
                addLog('æ­£åœ¨åŠ è½½æµ‹è¯•ç”¨ä¾‹...', 'info');

                const response = await axios.get(`${API_BASE}/testcases?size=100`);
                console.log('æµ‹è¯•ç”¨ä¾‹APIå“åº”:', response.data);

                if (response.data.code === 200) {
                    testcases = response.data.data.items;
                    console.log('åŠ è½½çš„æµ‹è¯•ç”¨ä¾‹:', testcases);
                    addLog(`æˆåŠŸåŠ è½½ ${testcases.length} ä¸ªæµ‹è¯•ç”¨ä¾‹`, 'success');
                    renderTestcaseOptions();
                } else {
                    console.error('APIè¿”å›é”™è¯¯:', response.data);
                    addLog(`åŠ è½½å¤±è´¥: ${response.data.message}`, 'error');
                }
            } catch (error) {
                console.error('åŠ è½½æµ‹è¯•ç”¨ä¾‹å¤±è´¥:', error);
                addLog(`åŠ è½½æµ‹è¯•ç”¨ä¾‹å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function renderTestcaseOptions() {
            console.log('å¼€å§‹æ¸²æŸ“æµ‹è¯•ç”¨ä¾‹é€‰é¡¹...');
            const select = document.getElementById('testcaseSelect');

            if (!select) {
                console.error('æ‰¾ä¸åˆ°testcaseSelectå…ƒç´ ');
                addLog('é¡µé¢å…ƒç´ åŠ è½½é”™è¯¯', 'error');
                return;
            }

            select.innerHTML = '<option value="">è¯·é€‰æ‹©æµ‹è¯•ç”¨ä¾‹</option>';

            console.log('è¦æ¸²æŸ“çš„æµ‹è¯•ç”¨ä¾‹æ•°é‡:', testcases.length);

            testcases.forEach((testcase, index) => {
                console.log(`æ¸²æŸ“æµ‹è¯•ç”¨ä¾‹ ${index + 1}:`, testcase);
                const option = document.createElement('option');
                option.value = testcase.id;
                option.textContent = `${testcase.name} (${testcase.category || 'æœªåˆ†ç±»'})`;
                select.appendChild(option);
            });

            addLog(`å·²åŠ è½½ ${testcases.length} ä¸ªæµ‹è¯•ç”¨ä¾‹åˆ°ä¸‹æ‹‰èœå•`, 'success');
        }

        async function loadTestcaseSteps(testcaseId) {
            try {
                const response = await axios.get(`${API_BASE}/testcases/${testcaseId}`);
                if (response.data.code === 200) {
                    const testcase = response.data.data;
                    renderSteps(testcase.steps);
                }
            } catch (error) {
                addLog('åŠ è½½æµ‹è¯•æ­¥éª¤å¤±è´¥', 'error');
            }
        }

        function renderSteps(steps) {
            const stepList = document.getElementById('stepList');
            
            if (!steps || steps.length === 0) {
                stepList.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">âš ï¸</div>
                        <div>è¯¥æµ‹è¯•ç”¨ä¾‹æš‚æ— æ‰§è¡Œæ­¥éª¤</div>
                    </div>
                `;
                return;
            }

            stepList.innerHTML = steps.map((step, index) => `
                <div class="step-item" id="step-${index}">
                    <div class="step-icon pending" id="step-icon-${index}">
                        ${index + 1}
                    </div>
                    <div class="step-content">
                        <div class="step-title">${step.description || step.action}</div>
                        <div class="step-description">${JSON.stringify(step.params || {})}</div>
                        <div class="step-time" id="step-time-${index}"></div>
                    </div>
                </div>
            `).join('');
        }

        function clearStepList() {
            document.getElementById('stepList').innerHTML = `
                <div class="empty-state">
                    <div class="icon">ğŸ“</div>
                    <div>è¯·é€‰æ‹©æµ‹è¯•ç”¨ä¾‹æŸ¥çœ‹æ‰§è¡Œæ­¥éª¤</div>
                </div>
            `;
        }

        async function startExecution() {
            const testcaseId = document.getElementById('testcaseSelect').value;
            if (!testcaseId) {
                addLog('è¯·å…ˆé€‰æ‹©æµ‹è¯•ç”¨ä¾‹', 'warning');
                return;
            }

            const mode = document.querySelector('input[name="mode"]:checked').value;
            const execution_type = document.querySelector('input[name="execution_type"]:checked').value;

            // é‡ç½®æ­¥éª¤çŠ¶æ€
            const stepIcons = document.querySelectorAll('.step-icon');
            stepIcons.forEach(icon => {
                icon.className = 'step-icon pending';
                icon.textContent = icon.id.split('-')[2] ? parseInt(icon.id.split('-')[2]) + 1 : '';
            });

            // æ¸…ç©ºæ—¥å¿—
            document.getElementById('logContainer').innerHTML = '';

            // æ˜¾ç¤ºè¿›åº¦æ¡
            document.getElementById('progressContainer').style.display = 'block';
            updateProgress(0, stepIcons.length);

            addLog(`å‡†å¤‡æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹ ID: ${testcaseId}`, 'info');
            addLog(`æ‰§è¡Œæ¨¡å¼: ${mode}`, 'info');
            addLog(`æ‰§è¡Œç±»å‹: ${execution_type}`, 'info');

            // æ ¹æ®æ‰§è¡Œç±»å‹é€‰æ‹©ä¸åŒçš„æ‰§è¡Œè·¯å¾„
            if (execution_type === 'local-proxy') {
                // æœ¬åœ°ä»£ç†æ¨¡å¼ï¼šé€šè¿‡æœ¬åœ°æœåŠ¡å™¨æ‰§è¡Œ
                await startLocalProxyExecution(testcaseId, mode);
            } else if (execution_type === 'bridge') {
                // Chromeæ¡¥æ¥æ¨¡å¼ï¼šå®¢æˆ·ç«¯æ‰§è¡Œ
                await startBridgeExecution(testcaseId, mode);
            } else {
                // äº‘ç«¯/æœ¬åœ°æ¨¡å¼ï¼šæœåŠ¡å™¨æ‰§è¡Œ
                await startServerExecution(testcaseId, mode, execution_type);
            }
        }

        async function startBridgeExecution(testcaseId, mode) {
            addLog('ğŸŒ‰ å¯åŠ¨Chromeæ¡¥æ¥æ¨¡å¼ï¼ˆç›´æ¥æ‰§è¡Œï¼‰', 'info');

            try {
                // 1. è·å–æµ‹è¯•ç”¨ä¾‹æ•°æ®
                addLog('æ­£åœ¨è·å–æµ‹è¯•ç”¨ä¾‹æ•°æ®...', 'info');
                const testcaseResponse = await axios.get(`${API_BASE}/testcases/${testcaseId}`);
                if (testcaseResponse.data.code !== 200) {
                    addLog('è·å–æµ‹è¯•ç”¨ä¾‹å¤±è´¥', 'error');
                    return;
                }

                const testcase = testcaseResponse.data.data;
                addLog(`âœ… è·å–æµ‹è¯•ç”¨ä¾‹: ${testcase.name}`, 'success');

                // 2. æ£€æŸ¥MidSceneJSæ‰©å±•
                addLog('ğŸ” æ£€æŸ¥MidSceneJSæ‰©å±•è¿æ¥...', 'info');
                if (!await checkMidSceneExtension()) {
                    addLog('âŒ æœªæ£€æµ‹åˆ°MidSceneJSæ‰©å±•', 'error');
                    addLog('ğŸ“‹ è¯·ç¡®ä¿ï¼š', 'warning');
                    addLog('  1. å·²å®‰è£…å®˜æ–¹MidSceneJS Chromeæ‰©å±•', 'warning');
                    addLog('  2. æ‰©å±•å·²å¯ç”¨å¹¶é…ç½®AI APIå¯†é’¥', 'warning');
                    addLog('  3. åœ¨æ‰©å±•ä¸­ç‚¹å‡»"Allow connection"', 'warning');
                    return;
                }

                addLog('âœ… MidSceneJSæ‰©å±•è¿æ¥æˆåŠŸ', 'success');

                // 3. å°è¯•ç›´æ¥æ‰§è¡Œï¼Œå¤±è´¥åˆ™ç”Ÿæˆè„šæœ¬
                addLog('ğŸš€ å°è¯•ç›´æ¥é€šè¿‡æ‰©å±•æ‰§è¡Œ...', 'info');

                try {
                    await executeThroughMidSceneExtension(testcase, mode);
                } catch (executionError) {
                    addLog(`âŒ ç›´æ¥æ‰§è¡Œå¤±è´¥: ${executionError.message}`, 'error');
                    addLog('ğŸ”„ åˆ‡æ¢åˆ°è„šæœ¬ç”Ÿæˆæ¨¡å¼...', 'warning');

                    // å¤‡ç”¨æ–¹æ¡ˆï¼šç”Ÿæˆè„šæœ¬
                    const script = generateMidSceneScript(testcase, mode);
                    downloadScript(script, `${testcase.name}-bridge.mjs`);
                    showBridgeInstructions(testcase.name);
                }

            } catch (error) {
                console.error('æ¡¥æ¥æ¨¡å¼æ‰§è¡Œé”™è¯¯:', error);
                addLog(`âŒ Chromeæ¡¥æ¥æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
                addLog('ğŸ’¡ è¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯', 'warning');
            }
        }

        function generateMidSceneScript(testcase, mode) {
            try {
                // æ£€æŸ¥stepsæ˜¯å¦å·²ç»æ˜¯å¯¹è±¡
                let steps;
                if (typeof testcase.steps === 'string') {
                    steps = JSON.parse(testcase.steps || '[]');
                } else if (Array.isArray(testcase.steps)) {
                    steps = testcase.steps;
                } else {
                    steps = [];
                }

                console.log('æµ‹è¯•ç”¨ä¾‹æ­¥éª¤:', steps);

                // å¦‚æœæ­¥éª¤ä¸ºç©ºï¼Œåˆ›å»ºä¸€ä¸ªç®€å•çš„ç¤ºä¾‹è„šæœ¬
                if (!steps || steps.length === 0) {
                    addLog('âš ï¸ æµ‹è¯•ç”¨ä¾‹æ²¡æœ‰æ­¥éª¤ï¼Œç”Ÿæˆç¤ºä¾‹è„šæœ¬', 'warning');
                    return generateSimpleScript(testcase.name);
                }

                // ä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥é¿å…æ¨¡æ¿å­—ç¬¦ä¸²åµŒå¥—é—®é¢˜
                let script = '// MidSceneJSæ¡¥æ¥æ¨¡å¼è„šæœ¬\n';
                script += '// æµ‹è¯•ç”¨ä¾‹: ' + testcase.name + '\n';
                script += '// ç”Ÿæˆæ—¶é—´: ' + new Date().toLocaleString() + '\n\n';
                script += 'import { AgentOverChromeBridge } from \'@midscene/web/bridge-mode\';\n\n';
                script += 'const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\n';
                script += 'Promise.resolve(\n';
                script += '  (async () => {\n';
                script += '    const agent = new AgentOverChromeBridge();\n';
                script += '    \n';
                script += '    try {\n';
                script += '      console.log(\'ğŸŒ‰ å¼€å§‹æ¡¥æ¥æ¨¡å¼æ‰§è¡Œ: ' + testcase.name + '\');\n';
                script += '      \n';

                // ç¡®å®šè¿æ¥æ–¹å¼
                const firstStep = steps[0] || {};
                const startUrl = firstStep.params?.url || 'https://www.baidu.com';

                if (firstStep.action === 'navigate' && startUrl) {
                    script += '      // è¿æ¥åˆ°æ–°æ ‡ç­¾é¡µå¹¶å¯¼èˆª\n';
                    script += '      await agent.connectNewTabWithUrl(\'' + startUrl + '\');\n';
                    script += '      console.log(\'âœ… å·²è¿æ¥åˆ°æ–°æ ‡ç­¾é¡µ: ' + startUrl + '\');\n';
                    script += '      \n';
                    // è·³è¿‡ç¬¬ä¸€ä¸ªå¯¼èˆªæ­¥éª¤
                    steps.shift();
                } else {
                    script += '      // è¿æ¥åˆ°å½“å‰æ ‡ç­¾é¡µ\n';
                    script += '      await agent.connectCurrentTab();\n';
                    script += '      console.log(\'âœ… å·²è¿æ¥åˆ°å½“å‰æ ‡ç­¾é¡µ\');\n';
                    script += '      \n';
                }

                // ç”Ÿæˆæ­¥éª¤æ‰§è¡Œä»£ç 
                steps.forEach((step, index) => {
                    const { action, params = {}, description } = step;
                    const stepNum = index + 1;

                    script += '      // æ­¥éª¤ ' + stepNum + ': ' + (description || action) + '\n';

                    switch (action) {
                        case 'navigate':
                            if (params.url) {
                                script += '      await agent.goto(\'' + params.url + '\');\n';
                                script += '      console.log(\'ğŸ”— å¯¼èˆªåˆ°: ' + params.url + '\');\n';
                            }
                            break;

                        case 'click':
                            if (params.locate) {
                                script += '      await agent.ai(\'click "' + params.locate + '"\');\n';
                                script += '      console.log(\'ğŸ‘† ç‚¹å‡»: ' + params.locate + '\');\n';
                            }
                            break;

                        case 'type':
                            if (params.locate && params.text) {
                                script += '      await agent.ai(\'type "' + params.text + '" in "' + params.locate + '"\');\n';
                                script += '      console.log(\'âŒ¨ï¸ è¾“å…¥æ–‡æœ¬: ' + params.text + ' åˆ° ' + params.locate + '\');\n';
                            }
                            break;

                        case 'wait':
                            const waitTime = params.time || 1000;
                            script += '      await sleep(' + waitTime + ');\n';
                            script += '      console.log(\'â±ï¸ ç­‰å¾… ' + waitTime + 'ms\');\n';
                            break;

                        case 'assert':
                            if (params.condition) {
                                script += '      await agent.aiAssert(\'' + params.condition + '\');\n';
                                script += '      console.log(\'âœ… æ–­è¨€: ' + params.condition + '\');\n';
                            }
                            break;

                        default:
                            // é€šç”¨AIæ“ä½œ
                            let aiInstruction = description || action;
                            if (params.locate) {
                                aiInstruction = action + ' ' + params.locate;
                                if (params.text) {
                                    aiInstruction += ' with text "' + params.text + '"';
                                }
                            }
                            script += '      await agent.ai(\'' + aiInstruction + '\');\n';
                            script += '      console.log(\'ğŸ¤– AIæ“ä½œ: ' + aiInstruction + '\');\n';
                            break;
                    }

                    script += '\n';
                });

                script += '      console.log(\'ğŸ‰ æµ‹è¯•æ‰§è¡Œå®Œæˆï¼\');\n';
                script += '      await agent.destroy();\n';
                script += '      \n';
                script += '    } catch (error) {\n';
                script += '      console.error(\'âŒ æµ‹è¯•æ‰§è¡Œå¤±è´¥:\', error.message);\n';
                script += '      await agent.destroy();\n';
                script += '      process.exit(1);\n';
                script += '    }\n';
                script += '  })()\n';
                script += ');\n';

                return script;

            } catch (error) {
                console.error('è„šæœ¬ç”Ÿæˆé”™è¯¯:', error);
                console.error('æµ‹è¯•ç”¨ä¾‹æ•°æ®:', testcase);
                console.error('æ­¥éª¤æ•°æ®ç±»å‹:', typeof testcase.steps);
                console.error('æ­¥éª¤æ•°æ®å†…å®¹:', testcase.steps);
                throw new Error('è„šæœ¬ç”Ÿæˆå¤±è´¥: ' + error.message);
            }
        }

        function generateSimpleScript(testcaseName) {
            // ç”Ÿæˆä¸€ä¸ªç®€å•çš„ç¤ºä¾‹è„šæœ¬
            let script = '// MidSceneJSæ¡¥æ¥æ¨¡å¼è„šæœ¬\n';
            script += '// æµ‹è¯•ç”¨ä¾‹: ' + testcaseName + '\n';
            script += '// ç”Ÿæˆæ—¶é—´: ' + new Date().toLocaleString() + '\n\n';
            script += 'import { AgentOverChromeBridge } from \'@midscene/web/bridge-mode\';\n\n';
            script += 'const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\n';
            script += 'Promise.resolve(\n';
            script += '  (async () => {\n';
            script += '    const agent = new AgentOverChromeBridge();\n';
            script += '    \n';
            script += '    try {\n';
            script += '      console.log(\'ğŸŒ‰ å¼€å§‹æ¡¥æ¥æ¨¡å¼æ‰§è¡Œ: ' + testcaseName + '\');\n';
            script += '      \n';
            script += '      // è¿æ¥åˆ°æ–°æ ‡ç­¾é¡µå¹¶å¯¼èˆª\n';
            script += '      await agent.connectNewTabWithUrl(\'https://www.baidu.com\');\n';
            script += '      console.log(\'âœ… å·²è¿æ¥åˆ°æ–°æ ‡ç­¾é¡µ: https://www.baidu.com\');\n';
            script += '      \n';
            script += '      // ç¤ºä¾‹æ­¥éª¤ï¼šæœç´¢\n';
            script += '      await agent.ai(\'type "Hello World" in search box\');\n';
            script += '      console.log(\'âŒ¨ï¸ è¾“å…¥æ–‡æœ¬: Hello World\');\n';
            script += '      \n';
            script += '      await sleep(2000);\n';
            script += '      console.log(\'â±ï¸ ç­‰å¾… 2000ms\');\n';
            script += '      \n';
            script += '      console.log(\'ğŸ‰ æµ‹è¯•æ‰§è¡Œå®Œæˆï¼\');\n';
            script += '      await agent.destroy();\n';
            script += '      \n';
            script += '    } catch (error) {\n';
            script += '      console.error(\'âŒ æµ‹è¯•æ‰§è¡Œå¤±è´¥:\', error.message);\n';
            script += '      await agent.destroy();\n';
            script += '      process.exit(1);\n';
            script += '    }\n';
            script += '  })()\n';
            script += ');\n';

            return script;
        }

        function downloadScript(content, filename) {
            const blob = new Blob([content], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addLog(`ğŸ“ è„šæœ¬å·²ä¸‹è½½: ${filename}`, 'success');
        }

        function showBridgeInstructions(testcaseName) {
            addLog('', 'info');
            addLog('ğŸš€ æ¡¥æ¥æ¨¡å¼æ‰§è¡ŒæŒ‡å—ï¼š', 'info');
            addLog('', 'info');
            addLog('ğŸ“‹ æ­¥éª¤1ï¼šå®‰è£…MidSceneJSæ‰©å±•', 'info');
            addLog('  è®¿é—®ï¼šhttps://chromewebstore.google.com/detail/midscene/gbldofcpkknbggpkmbdaefngejllnief', 'info');
            addLog('  å®‰è£…å®˜æ–¹MidSceneJSæ‰©å±•', 'info');
            addLog('', 'info');
            addLog('ğŸ”§ æ­¥éª¤2ï¼šå‡†å¤‡æœ¬åœ°ç¯å¢ƒ', 'info');
            addLog('  mkdir midscene-bridge && cd midscene-bridge', 'info');
            addLog('  npm init -y', 'info');
            addLog('  npm install @midscene/web', 'info');
            addLog('', 'info');
            addLog('â–¶ï¸ æ­¥éª¤3ï¼šæ‰§è¡Œè„šæœ¬', 'info');
            addLog('  1. å°†ä¸‹è½½çš„è„šæœ¬æ–‡ä»¶æ”¾åˆ°é¡¹ç›®ç›®å½•', 'info');
            addLog('  2. åœ¨Chromeæ‰©å±•ä¸­ç‚¹å‡»"Allow connection"', 'info');
            addLog(`  3. è¿è¡Œ: node ${testcaseName}-bridge.mjs`, 'info');
            addLog('', 'info');
            addLog('ğŸ¯ æ‰§è¡Œæ•ˆæœï¼š', 'success');
            addLog('  âœ… åœ¨æ‚¨çš„Chromeæµè§ˆå™¨ä¸­çœ‹åˆ°çœŸå®çš„è‡ªåŠ¨åŒ–è¿‡ç¨‹', 'success');
            addLog('  âœ… å¯ä»¥è§‚å¯Ÿæ¯ä¸ªæ­¥éª¤çš„æ‰§è¡Œæ•ˆæœ', 'success');
            addLog('  âœ… çœŸæ­£çš„å®¢æˆ·ç«¯æ‰§è¡Œï¼Œæ— éœ€æœåŠ¡å™¨', 'success');
            addLog('', 'info');
            addLog('ğŸ’¡ æç¤ºï¼šç¡®ä¿åœ¨æ‰§è¡Œå‰é…ç½®å¥½AI APIå¯†é’¥ç¯å¢ƒå˜é‡', 'warning');
        }

        async function startServerExecution(testcaseId, mode, execution_type) {
            addLog(`â˜ï¸ å¯åŠ¨${execution_type === 'cloud' ? 'äº‘ç«¯' : 'æœ¬åœ°'}æ¨¡å¼ï¼ˆæœåŠ¡å™¨æ‰§è¡Œï¼‰`, 'info');

            try {
                // å‘é€HTTPæ‰§è¡Œè¯·æ±‚åˆ°æœåŠ¡å™¨
                const response = await axios.post(`${API_BASE}/executions/start`, {
                    testcase_id: parseInt(testcaseId),
                    mode: mode,
                    execution_type: execution_type
                });

                if (response.data.code === 200) {
                    currentExecution = response.data.data.execution_id;
                    addLog(`âœ… å¼€å§‹æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹ (æ¨¡å¼: ${mode})`, 'info');
                    addLog(response.data.data.message, 'info');

                    // å¼€å§‹è½®è¯¢çŠ¶æ€
                    startPolling(currentExecution);

                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                } else {
                    addLog(`âŒ æ‰§è¡Œå¯åŠ¨å¤±è´¥: ${response.data.message}`, 'error');
                }
            } catch (error) {
                addLog(`âŒ æ‰§è¡Œå¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ¡¥æ¥æ¨¡å¼ä¸éœ€è¦æ‰©å±•æ£€æµ‹ï¼Œç›´æ¥ç”Ÿæˆè„šæœ¬

        // æ¡¥æ¥æ¨¡å¼ä¸éœ€è¦ç›´æ¥æ‰§è¡Œï¼Œåªç”Ÿæˆè„šæœ¬

        async function executeThroughMidSceneExtension(testcase, mode) {
            let agent = null;

            try {
                // è§£ææµ‹è¯•æ­¥éª¤
                let steps;
                if (typeof testcase.steps === 'string') {
                    steps = JSON.parse(testcase.steps || '[]');
                } else if (Array.isArray(testcase.steps)) {
                    steps = testcase.steps;
                } else {
                    steps = [];
                }

                if (steps.length === 0) {
                    addLog('âš ï¸ æµ‹è¯•ç”¨ä¾‹æ²¡æœ‰æ­¥éª¤', 'warning');
                    return;
                }

                addLog(`ğŸ“‹ å¼€å§‹æ‰§è¡Œ ${steps.length} ä¸ªæµ‹è¯•æ­¥éª¤`, 'info');

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                // åˆ›å»ºMidSceneä»£ç†
                addLog('ğŸ”Œ åˆå§‹åŒ–MidSceneä»£ç†...', 'info');

                try {
                    // æ£€æŸ¥å…¨å±€å¯¹è±¡
                    if (window.AgentOverChromeBridge) {
                        agent = new window.AgentOverChromeBridge();
                        addLog('âœ… ä½¿ç”¨å…¨å±€AgentOverChromeBridgeåˆ›å»ºä»£ç†', 'success');
                    } else {
                        // å°è¯•ä»CDNåŠ è½½
                        addLog('ğŸ”„ å°è¯•ä»CDNåŠ è½½MidSceneJS...', 'info');
                        await loadMidSceneFromCDN();

                        if (window.AgentOverChromeBridge) {
                            agent = new window.AgentOverChromeBridge();
                            addLog('âœ… ä»CDNåŠ è½½å¹¶åˆ›å»ºä»£ç†æˆåŠŸ', 'success');
                        } else {
                            throw new Error('æ— æ³•è·å–AgentOverChromeBridgeç±»');
                        }
                    }
                } catch (createError) {
                    addLog(`âŒ æ— æ³•åˆ›å»ºMidSceneä»£ç†: ${createError.message}`, 'error');
                    addLog('ğŸ’¡ è¯·ç¡®ä¿MidSceneJSæ‰©å±•å·²æ­£ç¡®å®‰è£…å’Œé…ç½®', 'warning');
                    return;
                }

                // è¿æ¥åˆ°æ ‡ç­¾é¡µ
                const firstStep = steps[0];
                if (firstStep && firstStep.action === 'navigate' && firstStep.params?.url) {
                    addLog(`ğŸ”— è¿æ¥åˆ°æ–°æ ‡ç­¾é¡µ: ${firstStep.params.url}`, 'info');

                    try {
                        await agent.connectNewTabWithUrl(firstStep.params.url);
                        addLog('âœ… å·²è¿æ¥åˆ°æ–°æ ‡ç­¾é¡µ', 'success');
                        steps.shift(); // è·³è¿‡ç¬¬ä¸€ä¸ªå¯¼èˆªæ­¥éª¤
                    } catch (connectError) {
                        addLog(`âŒ è¿æ¥æ–°æ ‡ç­¾é¡µå¤±è´¥: ${connectError.message}`, 'error');
                        return;
                    }
                } else {
                    addLog('ğŸ”— è¿æ¥åˆ°å½“å‰æ ‡ç­¾é¡µ...', 'info');

                    try {
                        await agent.connectCurrentTab();
                        addLog('âœ… å·²è¿æ¥åˆ°å½“å‰æ ‡ç­¾é¡µ', 'success');
                    } catch (connectError) {
                        addLog(`âŒ è¿æ¥å½“å‰æ ‡ç­¾é¡µå¤±è´¥: ${connectError.message}`, 'error');
                        return;
                    }
                }

                // æ‰§è¡Œæ¯ä¸ªæ­¥éª¤
                for (let i = 0; i < steps.length; i++) {
                    const step = steps[i];
                    const stepNum = i + 1;

                    addLog(`ğŸ”„ æ‰§è¡Œæ­¥éª¤ ${stepNum}: ${step.description || step.action}`, 'info');

                    try {
                        await executeStepWithAgent(agent, step);
                        addLog(`âœ… æ­¥éª¤ ${stepNum} æ‰§è¡ŒæˆåŠŸ`, 'success');

                        // çŸ­æš‚å»¶è¿Ÿï¼Œè®©ç”¨æˆ·çœ‹åˆ°æ‰§è¡Œè¿‡ç¨‹
                        await new Promise(resolve => setTimeout(resolve, 1500));

                    } catch (stepError) {
                        addLog(`âŒ æ­¥éª¤ ${stepNum} æ‰§è¡Œå¤±è´¥: ${stepError.message}`, 'error');
                        console.error('æ­¥éª¤æ‰§è¡Œè¯¦ç»†é”™è¯¯:', stepError);
                        break;
                    }
                }

                addLog('ğŸ‰ æµ‹è¯•æ‰§è¡Œå®Œæˆï¼', 'success');

            } catch (error) {
                addLog(`âŒ æ‰§è¡Œè¿‡ç¨‹å¼‚å¸¸: ${error.message}`, 'error');
                console.error('æ‰§è¡Œè¿‡ç¨‹è¯¦ç»†é”™è¯¯:', error);
            } finally {
                // é”€æ¯ä»£ç†
                if (agent) {
                    try {
                        await agent.destroy();
                        addLog('ğŸ§¹ MidSceneä»£ç†å·²æ¸…ç†', 'info');
                    } catch (destroyError) {
                        console.error('ä»£ç†æ¸…ç†å¤±è´¥:', destroyError);
                    }
                }

                // æ¢å¤æŒ‰é’®çŠ¶æ€
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }

        async function executeStepWithAgent(agent, step) {
            const { action, params = {}, description } = step;

            console.log('æ‰§è¡Œæ­¥éª¤:', { action, params, description });

            switch (action) {
                case 'navigate':
                    if (params.url) {
                        // å¯¼èˆªæ­¥éª¤é€šå¸¸åœ¨è¿æ¥æ—¶å·²å¤„ç†ï¼Œè¿™é‡Œå¯ä»¥è·³è¿‡æˆ–ä½¿ç”¨goto
                        console.log(`å¯¼èˆªåˆ°: ${params.url}`);
                        // await agent.goto(params.url); // å¦‚æœéœ€è¦çš„è¯
                    }
                    break;

                case 'click':
                    if (params.locate) {
                        await agent.aiTap(params.locate);
                        console.log(`ç‚¹å‡»: ${params.locate}`);
                    }
                    break;

                case 'type':
                    if (params.locate && params.text) {
                        await agent.aiInput(params.text, params.locate);
                        console.log(`è¾“å…¥æ–‡æœ¬: ${params.text} åˆ° ${params.locate}`);
                    }
                    break;

                case 'wait':
                    const waitTime = params.time || 1000;
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    console.log(`ç­‰å¾…: ${waitTime}ms`);
                    break;

                case 'assert':
                    if (params.condition) {
                        await agent.aiAssert(params.condition);
                        console.log(`æ–­è¨€: ${params.condition}`);
                    }
                    break;

                case 'ai_input':
                    // å¤„ç†è‡ªå®šä¹‰çš„ai_inputåŠ¨ä½œ
                    if (params.locate && params.text) {
                        await agent.aiInput(params.text, params.locate);
                        console.log(`AIè¾“å…¥: ${params.text} åˆ° ${params.locate}`);
                    }
                    break;

                default:
                    // é€šç”¨AIæ“ä½œ
                    let aiInstruction = description || action;
                    if (params.locate) {
                        if (action.includes('click') || action.includes('ç‚¹å‡»')) {
                            aiInstruction = `click ${params.locate}`;
                        } else if (action.includes('input') || action.includes('è¾“å…¥')) {
                            aiInstruction = `type "${params.text || ''}" in ${params.locate}`;
                        } else {
                            aiInstruction = `${action} ${params.locate}`;
                            if (params.text) {
                                aiInstruction += ` with text "${params.text}"`;
                            }
                        }
                    }

                    await agent.ai(aiInstruction);
                    console.log(`AIæ“ä½œ: ${aiInstruction}`);
                    break;
            }
        }

        function updateStepStatus(stepIndex, status) {
            const stepIcon = document.getElementById(`step-icon-${stepIndex}`);
            if (stepIcon) {
                stepIcon.className = `step-icon ${status}`;
                if (status === 'running') {
                    stepIcon.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                } else if (status === 'success') {
                    stepIcon.innerHTML = '<i class="fas fa-check"></i>';
                } else if (status === 'failed') {
                    stepIcon.innerHTML = '<i class="fas fa-times"></i>';
                }
            }
        }

        function stopExecution() {
            if (currentExecution) {
                // TODO: å®ç°åœæ­¢æ‰§è¡ŒåŠŸèƒ½
                addLog('åœæ­¢æ‰§è¡ŒåŠŸèƒ½å¼€å‘ä¸­...', 'warning');
            }
        }

        function updateExecutionStatus(status, message) {
            const statusEl = document.getElementById('executionStatus');
            statusEl.className = `execution-status status-${status}`;
            statusEl.textContent = `çŠ¶æ€: ${message}`;
        }

        function updateStepStatus(stepIndex, status) {
            const iconEl = document.getElementById(`step-icon-${stepIndex}`);
            if (iconEl) {
                iconEl.className = `step-icon ${status}`;
                if (status === 'success') {
                    iconEl.textContent = 'âœ“';
                } else if (status === 'failed') {
                    iconEl.textContent = 'âœ—';
                } else if (status === 'running') {
                    iconEl.textContent = 'â³';
                }
            }
        }

        function updateProgress(current, total) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            const percentage = total > 0 ? (current / total) * 100 : 0;
            progressFill.style.width = percentage + '%';
            progressText.textContent = `${current} / ${total}`;
        }

        function getCurrentTotalSteps() {
            const stepIcons = document.querySelectorAll('.step-icon');
            return stepIcons.length;
        }

        function addLog(message, level = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-level-${level}">${message}</span>
            `;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function showScreenshot(path) {
            const container = document.getElementById('screenshotContainer');
            const img = document.getElementById('currentScreenshot');

            img.src = path;
            container.style.display = 'block';
        }

        // æœ¬åœ°ä»£ç†ç›¸å…³å‡½æ•°
        async function checkLocalProxyConnection() {
            try {
                const response = await fetch(`${LOCAL_PROXY_URL}/health`, {
                    method: 'GET',
                    timeout: 3000
                });

                if (response.ok) {
                    localProxyConnected = true;
                    updateLocalProxyStatus('connected');
                    return true;
                } else {
                    throw new Error('æœåŠ¡å™¨å“åº”å¼‚å¸¸');
                }
            } catch (error) {
                localProxyConnected = false;
                updateLocalProxyStatus('disconnected');
                return false;
            }
        }

        function updateLocalProxyStatus(status) {
            const statusElement = document.getElementById('localProxyStatus');
            if (!statusElement) return;

            switch (status) {
                case 'connected':
                    statusElement.className = 'badge bg-success';
                    statusElement.textContent = 'å·²è¿æ¥';
                    break;
                case 'disconnected':
                    statusElement.className = 'badge bg-danger';
                    statusElement.textContent = 'æœªè¿æ¥';
                    break;
                case 'checking':
                default:
                    statusElement.className = 'badge bg-secondary';
                    statusElement.textContent = 'æ£€æµ‹ä¸­...';
                    break;
            }
        }

        function connectLocalProxyWebSocket() {
            if (localProxySocket) {
                localProxySocket.disconnect();
            }

            try {
                localProxySocket = io(LOCAL_PROXY_URL);

                localProxySocket.on('connect', () => {
                    console.log('âœ… WebSocketè¿æ¥åˆ°æœ¬åœ°ä»£ç†æœåŠ¡å™¨');
                    localProxyConnected = true;
                    updateLocalProxyStatus('connected');
                });

                localProxySocket.on('disconnect', () => {
                    console.log('âŒ WebSocketæ–­å¼€è¿æ¥');
                    localProxyConnected = false;
                    updateLocalProxyStatus('disconnected');
                });

                // ç›‘å¬æ‰§è¡Œäº‹ä»¶
                localProxySocket.on('execution-start', (data) => {
                    addLog(`ğŸš€ å¼€å§‹æ‰§è¡Œ: ${data.testcase}`, 'info');
                });

                localProxySocket.on('step-progress', (data) => {
                    addLog(`ğŸ”„ æ­¥éª¤ ${data.stepIndex + 1}/${data.totalSteps}: ${data.step}`, 'info');
                    updateProgress(data.stepIndex + 1, data.totalSteps);
                });

                localProxySocket.on('step-complete', (data) => {
                    addLog(`âœ… æ­¥éª¤ ${data.stepIndex + 1} å®Œæˆ`, 'success');
                });

                localProxySocket.on('log-message', (data) => {
                    addLog(data.message, data.level);
                });

                localProxySocket.on('screenshot-taken', (data) => {
                    // æ˜¾ç¤ºæˆªå›¾
                    const screenshot = {
                        step_index: data.stepIndex,
                        step_name: `æ­¥éª¤ ${data.stepIndex + 1}`,
                        path: `data:image/png;base64,${data.screenshot}`
                    };
                    addScreenshotToHistory(screenshot);
                });

                localProxySocket.on('execution-complete', (data) => {
                    addLog(`ğŸ‰ æ‰§è¡Œå®Œæˆï¼è€—æ—¶: ${Math.round(data.duration / 1000)}ç§’`, 'success');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                });

                localProxySocket.on('execution-error', (data) => {
                    addLog(`âŒ æ‰§è¡Œå¤±è´¥: ${data.error}`, 'error');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                });

                localProxySocket.on('execution-stopped', (data) => {
                    addLog('â¹ï¸ æ‰§è¡Œå·²åœæ­¢', 'warning');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                });

            } catch (error) {
                console.error('WebSocketè¿æ¥å¤±è´¥:', error);
                localProxyConnected = false;
                updateLocalProxyStatus('disconnected');
            }
        }

        async function startLocalProxyExecution(testcaseId, mode) {
            try {
                // è·å–æµ‹è¯•ç”¨ä¾‹æ•°æ®
                const testcaseResponse = await axios.get(`${API_BASE}/testcases/${testcaseId}`);
                if (testcaseResponse.data.code !== 200) {
                    addLog('è·å–æµ‹è¯•ç”¨ä¾‹å¤±è´¥', 'error');
                    return;
                }

                const testcase = testcaseResponse.data.data;

                // å‘é€æ‰§è¡Œè¯·æ±‚åˆ°æœ¬åœ°ä»£ç†æœåŠ¡å™¨
                const response = await fetch(`${LOCAL_PROXY_URL}/api/execute-testcase`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        testcase: testcase,
                        mode: mode
                    })
                });

                const result = await response.json();

                if (result.success) {
                    addLog(`âœ… æµ‹è¯•ç”¨ä¾‹å·²æäº¤æ‰§è¡Œ: ${result.executionId}`, 'success');
                    currentExecution = result.executionId;

                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                } else {
                    addLog(`âŒ æäº¤æ‰§è¡Œå¤±è´¥: ${result.error}`, 'error');
                }

            } catch (error) {
                addLog(`âŒ æœ¬åœ°ä»£ç†æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
                console.error('æœ¬åœ°ä»£ç†æ‰§è¡Œé”™è¯¯:', error);
            }
        }

        // æˆªå›¾å†å²å¤„ç†å‡½æ•°
        function clearScreenshotHistory() {
            screenshotHistory = [];
            const historyContainer = document.getElementById('screenshotHistory');
            historyContainer.innerHTML = '';
            document.getElementById('screenshotHistoryContainer').style.display = 'none';
        }

        function addScreenshotToHistory(screenshot) {
            screenshotHistory.push(screenshot);
            renderScreenshotHistory();

            // æ˜¾ç¤ºæˆªå›¾å†å²å®¹å™¨
            document.getElementById('screenshotHistoryContainer').style.display = 'block';
        }

        function renderScreenshotHistory() {
            const historyContainer = document.getElementById('screenshotHistory');
            historyContainer.innerHTML = '';

            screenshotHistory.forEach((screenshot, index) => {
                const item = document.createElement('div');
                item.className = 'screenshot-item';
                if (index === screenshotHistory.length - 1) {
                    item.classList.add('current'); // æ ‡è®°å½“å‰æˆªå›¾
                }

                item.innerHTML = `
                    <div class="step-index">${screenshot.step_index + 1}</div>
                    <img src="${screenshot.path}" alt="æ­¥éª¤ ${screenshot.step_index + 1} æˆªå›¾"
                         onerror="this.style.display='none'">
                    <div class="step-label">${screenshot.step_name}</div>
                `;

                // ç‚¹å‡»ç¼©ç•¥å›¾æ˜¾ç¤ºå¤§å›¾
                item.addEventListener('click', function() {
                    showScreenshotFullscreen(screenshot.path, screenshot.step_name);

                    // æ›´æ–°å½“å‰æˆªå›¾
                    showScreenshot(screenshot.path);

                    // æ›´æ–°å½“å‰æ ‡è®°
                    document.querySelectorAll('.screenshot-item').forEach(el => el.classList.remove('current'));
                    item.classList.add('current');
                });

                historyContainer.appendChild(item);
            });

            // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°æˆªå›¾
            historyContainer.scrollTop = historyContainer.scrollHeight;
        }

        function showScreenshotFullscreen(imagePath, stepName) {
            // åˆ›å»ºå…¨å±æŸ¥çœ‹å™¨
            let viewer = document.getElementById('screenshotViewer');
            if (!viewer) {
                viewer = document.createElement('div');
                viewer.id = 'screenshotViewer';
                viewer.className = 'screenshot-viewer';
                viewer.innerHTML = `
                    <div style="position: relative;">
                        <img id="fullscreenImage" src="" alt="æˆªå›¾">
                        <div style="position: absolute; top: -40px; left: 0; color: white; font-size: 16px; font-weight: bold;">
                            <span id="fullscreenTitle"></span>
                        </div>
                        <div style="position: absolute; top: -40px; right: 0; color: white; font-size: 24px; cursor: pointer;" onclick="closeScreenshotViewer()">
                            âœ•
                        </div>
                    </div>
                `;
                document.body.appendChild(viewer);

                // ç‚¹å‡»èƒŒæ™¯å…³é—­
                viewer.addEventListener('click', function(e) {
                    if (e.target === viewer) {
                        closeScreenshotViewer();
                    }
                });
            }

            document.getElementById('fullscreenImage').src = imagePath;
            document.getElementById('fullscreenTitle').textContent = stepName;
            viewer.style.display = 'flex';
        }

        function closeScreenshotViewer() {
            const viewer = document.getElementById('screenshotViewer');
            if (viewer) {
                viewer.style.display = 'none';
            }
        }

        // æ¨¡å¼åˆ‡æ¢å¤„ç†
        document.addEventListener('DOMContentLoaded', function() {
            const modeRadios = document.querySelectorAll('input[name="mode"]');
            const modeDescription = document.getElementById('modeDescription');

            // æ¨¡å¼æè¿°æ–‡æœ¬
            const modeDescriptions = {
                'headless': 'ğŸš€ <strong>æ— å¤´æ¨¡å¼</strong>: åå°æ‰§è¡Œï¼Œé€Ÿåº¦å¿«ï¼Œå¤±è´¥æ—¶åœæ­¢æ‰§è¡Œ',
                'browser': 'ğŸ–¥ï¸ <strong>æµè§ˆå™¨æ¨¡å¼</strong>: å¯è§†åŒ–æ‰§è¡Œï¼Œä¾¿äºè°ƒè¯•ï¼Œå¤±è´¥æ—¶ç»§ç»­æ‰§è¡Œ'
            };

            // ç›‘å¬æ¨¡å¼åˆ‡æ¢
            modeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.checked) {
                        modeDescription.innerHTML = modeDescriptions[this.value];
                    }
                });
            });
        });
        // æ‰§è¡Œç±»å‹ç›¸å…³å‡½æ•°
        function setupExecutionTypeListeners() {
            // æ‰§è¡Œç±»å‹é€‰æ‹©å˜åŒ–
            document.querySelectorAll('input[name="execution_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    updateExecutionTypeDescription(this.value);
                    if (this.value === 'bridge') {
                        showBridgeStatus();
                        checkBridgeStatus();
                    } else {
                        hideBridgeStatus();
                    }
                });
            });

            // å®‰è£…æŒ‡å—æŒ‰é’®
            const installBtn = document.getElementById('installGuideBtn');
            if (installBtn) {
                installBtn.addEventListener('click', function() {
                    showInstallationGuide();
                });
            }

            // åˆ·æ–°çŠ¶æ€æŒ‰é’®
            const refreshBtn = document.getElementById('refreshStatusBtn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', function() {
                    addLog('æ‰‹åŠ¨åˆ·æ–°æ¡¥æ¥çŠ¶æ€...', 'info');
                    checkBridgeStatus();
                });
            }

            // æ‰‹åŠ¨ç¡®è®¤æŒ‰é’®
            const manualConfirmBtn = document.getElementById('manualConfirmBtn');
            if (manualConfirmBtn) {
                manualConfirmBtn.addEventListener('click', function() {
                    toggleManualConfirmArea();
                });
            }

            // ç¡®è®¤çŠ¶æ€æŒ‰é’®
            const confirmStatusBtn = document.getElementById('confirmStatusBtn');
            if (confirmStatusBtn) {
                confirmStatusBtn.addEventListener('click', function() {
                    applyManualConfirmation();
                });
            }
        }

        function updateExecutionTypeDescription(type) {
            const descriptions = {
                'auto': 'ğŸ¤– <strong>æ™ºèƒ½é€‰æ‹©</strong>: è‡ªåŠ¨é€‰æ‹©æœ€ä½³æ‰§è¡Œæ–¹å¼',
                'bridge': 'ğŸŒ‰ <strong>Chromeæ¡¥æ¥</strong>: ä½¿ç”¨æœ¬åœ°Chromeæµè§ˆå™¨æ‰§è¡Œï¼ˆéœ€è¦æ‰©å±•ï¼‰',
                'cloud': 'â˜ï¸ <strong>äº‘ç«¯æ‰§è¡Œ</strong>: é›¶é…ç½®äº‘ç«¯æµè§ˆå™¨æ‰§è¡Œ',
                'local': 'ğŸ  <strong>æœ¬åœ°æ‰§è¡Œ</strong>: éœ€è¦æœ¬åœ°MidSceneJSæœåŠ¡å™¨'
            };

            const descElement = document.getElementById('modeDescription');
            if (descElement) {
                descElement.innerHTML = descriptions[type] || descriptions['auto'];
            }
        }

        function showBridgeStatus() {
            const bridgeStatus = document.getElementById('bridgeStatus');
            if (bridgeStatus) {
                bridgeStatus.style.display = 'block';
            }
        }

        function hideBridgeStatus() {
            const bridgeStatus = document.getElementById('bridgeStatus');
            if (bridgeStatus) {
                bridgeStatus.style.display = 'none';
            }
        }

        async function checkBridgeStatus() {
            try {
                addLog('æ­£åœ¨æ£€æŸ¥Chromeæ¡¥æ¥çŠ¶æ€...', 'info');

                // ä¼˜å…ˆæ£€æŸ¥æ‰‹åŠ¨ç¡®è®¤çŠ¶æ€
                const manualStatus = loadManualConfirmation();
                if (manualStatus) {
                    addLog('ä½¿ç”¨æ‰‹åŠ¨ç¡®è®¤çš„çŠ¶æ€', 'info');
                    updateBridgeStatusDisplay(manualStatus);
                    return;
                }

                // å‰ç«¯æ£€æµ‹
                const frontendStatus = await checkBridgeStatusFrontend();

                // åç«¯æ£€æµ‹ï¼ˆä»…æ£€æµ‹AIé…ç½®ï¼‰
                let backendStatus = { ai_configured: false };
                try {
                    const response = await axios.get(`${API_BASE}/bridge/status`);
                    if (response.data.code === 200) {
                        backendStatus = response.data.data;
                    }
                } catch (error) {
                    console.warn('åç«¯çŠ¶æ€æ£€æŸ¥å¤±è´¥ï¼Œä½¿ç”¨å‰ç«¯æ£€æµ‹ç»“æœ');
                }

                // åˆå¹¶å‰ç«¯å’Œåç«¯æ£€æµ‹ç»“æœ
                const combinedStatus = {
                    chrome_running: frontendStatus.chrome_running,
                    extension_installed: frontendStatus.extension_installed,
                    ai_configured: backendStatus.ai_configured || frontendStatus.ai_configured,
                    connection_test_passed: frontendStatus.connection_test_passed,
                    bridge_available: frontendStatus.chrome_running &&
                                    frontendStatus.extension_installed &&
                                    (backendStatus.ai_configured || frontendStatus.ai_configured),
                    message: getBridgeStatusMessage(frontendStatus, backendStatus)
                };

                updateBridgeStatusDisplay(combinedStatus);

            } catch (error) {
                console.error('æ£€æŸ¥æ¡¥æ¥çŠ¶æ€å¤±è´¥:', error);
                updateBridgeStatusDisplay({
                    chrome_running: false,
                    extension_installed: false,
                    ai_configured: false,
                    connection_test_passed: false,
                    bridge_available: false,
                    message: 'æ¡¥æ¥çŠ¶æ€æ£€æŸ¥å¤±è´¥'
                });
            }
        }

        async function checkBridgeStatusFrontend() {
            const status = {
                chrome_running: true, // å¦‚æœèƒ½è¿è¡Œè¿™ä¸ªJSï¼Œè¯´æ˜Chromeåœ¨è¿è¡Œ
                extension_installed: false,
                ai_configured: false,
                connection_test_passed: false
            };

            // æ£€æµ‹Chromeæ‰©å±•
            status.extension_installed = await detectMidSceneExtension();

            // æ£€æµ‹AIé…ç½®ï¼ˆé€šè¿‡localStorageæˆ–å…¶ä»–æ–¹å¼ï¼‰
            status.ai_configured = checkAIConfiguration();

            // æ£€æµ‹è¿æ¥èƒ½åŠ›
            status.connection_test_passed = await testBridgeConnection();

            return status;
        }

        async function checkMidSceneExtension() {
            try {
                console.log('ğŸ” æ£€æµ‹MidSceneJSæ‰©å±•...');

                // æ–¹æ³•1: æ£€æŸ¥æ‰©å±•æ³¨å…¥çš„å…¨å±€å¯¹è±¡
                if (window.AgentOverChromeBridge) {
                    console.log('âœ… æ£€æµ‹åˆ°AgentOverChromeBridgeå…¨å±€å¯¹è±¡');
                    return true;
                }

                if (window.midscene || window.MidScene) {
                    console.log('âœ… æ£€æµ‹åˆ°MidSceneå…¨å±€å¯¹è±¡');
                    return true;
                }

                // æ–¹æ³•2: å°è¯•åŠ è½½MidSceneJS CDN
                try {
                    await loadMidSceneFromCDN();
                    if (window.AgentOverChromeBridge) {
                        console.log('âœ… ä»CDNæˆåŠŸåŠ è½½MidSceneJS');
                        return true;
                    }
                } catch (cdnError) {
                    console.log('âŒ CDNåŠ è½½å¤±è´¥:', cdnError.message);
                }

                // æ–¹æ³•3: æ£€æŸ¥Chromeæ‰©å±•æ˜¯å¦æ³¨å…¥äº†è„šæœ¬
                const scripts = document.querySelectorAll('script[src*="midscene"], script[src*="chrome-extension"]');
                if (scripts.length > 0) {
                    console.log('âœ… æ£€æµ‹åˆ°MidSceneJSæ‰©å±•è„šæœ¬');
                    // ç­‰å¾…è„šæœ¬åŠ è½½
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    if (window.AgentOverChromeBridge) {
                        return true;
                    }
                }

                // ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤
                console.log('âš ï¸ æ— æ³•è‡ªåŠ¨æ£€æµ‹MidSceneJSç¯å¢ƒ');

                const userConfirm = confirm(
                    'æ— æ³•è‡ªåŠ¨æ£€æµ‹åˆ°MidSceneJSç¯å¢ƒã€‚\n\n' +
                    'æ¡¥æ¥æ¨¡å¼éœ€è¦ï¼š\n' +
                    '1. å®‰è£…å®˜æ–¹MidSceneJS Chromeæ‰©å±•\n' +
                    '2. æ‰©å±•å·²å¯ç”¨å¹¶é…ç½®AI APIå¯†é’¥\n' +
                    '3. åœ¨æ‰©å±•ä¸­ç‚¹å‡»"Allow connection"\n' +
                    '4. æ‰©å±•éœ€è¦æ³¨å…¥AgentOverChromeBridgeåˆ°é¡µé¢\n\n' +
                    'ç‚¹å‡»"ç¡®å®š"å°è¯•ç»§ç»­æ‰§è¡Œï¼Œç‚¹å‡»"å–æ¶ˆ"åœæ­¢æ‰§è¡Œã€‚'
                );

                return userConfirm;

            } catch (error) {
                console.error('æ‰©å±•æ£€æµ‹å¤±è´¥:', error);
                return false;
            }
        }

        async function loadMidSceneFromCDN() {
            return new Promise((resolve, reject) => {
                // å°è¯•ä»CDNåŠ è½½MidSceneJS
                const script = document.createElement('script');
                script.type = 'module';
                script.innerHTML = `
                    try {
                        const { AgentOverChromeBridge } = await import('https://unpkg.com/@midscene/web@latest/bridge-mode');
                        window.AgentOverChromeBridge = AgentOverChromeBridge;
                        window.dispatchEvent(new CustomEvent('midscene-loaded'));
                    } catch (error) {
                        window.dispatchEvent(new CustomEvent('midscene-load-error', { detail: error }));
                    }
                `;

                const onLoaded = () => {
                    cleanup();
                    resolve();
                };

                const onError = (event) => {
                    cleanup();
                    reject(new Error(event.detail?.message || 'CDNåŠ è½½å¤±è´¥'));
                };

                const cleanup = () => {
                    window.removeEventListener('midscene-loaded', onLoaded);
                    window.removeEventListener('midscene-load-error', onError);
                    document.head.removeChild(script);
                };

                window.addEventListener('midscene-loaded', onLoaded);
                window.addEventListener('midscene-load-error', onError);

                document.head.appendChild(script);

                // 5ç§’è¶…æ—¶
                setTimeout(() => {
                    cleanup();
                    reject(new Error('CDNåŠ è½½è¶…æ—¶'));
                }, 5000);
            });
        }

        async function testExtensionMessage() {
            return new Promise((resolve) => {
                try {
                    // å°è¯•å‘MidSceneJSæ‰©å±•å‘é€æ¶ˆæ¯
                    if (window.chrome && window.chrome.runtime) {
                        // è¿™é‡Œéœ€è¦çŸ¥é“MidSceneJSæ‰©å±•çš„ID
                        // æš‚æ—¶è¿”å›falseï¼Œç­‰å¾…ç”¨æˆ·æä¾›æ‰©å±•ID
                        console.log('Chromeæ‰©å±•APIå¯ç”¨ï¼Œä½†éœ€è¦æ‰©å±•ID');
                        resolve(false);
                    } else {
                        resolve(false);
                    }
                } catch (error) {
                    resolve(false);
                }
            });
        }

        function checkAIConfiguration() {
            try {
                // æ£€æŸ¥localStorageä¸­çš„AIé…ç½®
                const apiKey = localStorage.getItem('midscene_api_key') ||
                              localStorage.getItem('openai_api_key') ||
                              sessionStorage.getItem('midscene_api_key');

                if (apiKey) {
                    console.log('âœ… æ£€æµ‹åˆ°æœ¬åœ°AIé…ç½®');
                    return true;
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰ç¯å¢ƒå˜é‡ï¼ˆé€šè¿‡æŸç§æ–¹å¼æš´éœ²ï¼‰
                if (window.MIDSCENE_CONFIG || window.OPENAI_API_KEY) {
                    console.log('âœ… æ£€æµ‹åˆ°å…¨å±€AIé…ç½®');
                    return true;
                }

                console.log('âŒ æœªæ£€æµ‹åˆ°AIé…ç½®');
                return false;
            } catch (error) {
                console.warn('AIé…ç½®æ£€æµ‹å¤±è´¥:', error);
                return false;
            }
        }

        async function testBridgeConnection() {
            try {
                // æ£€æµ‹Node.jsç›¸å…³å·¥å…·æ˜¯å¦å¯ç”¨ï¼ˆé€šè¿‡æŸç§æ–¹å¼ï¼‰
                // è¿™ä¸ªåœ¨æµè§ˆå™¨ä¸­æ— æ³•ç›´æ¥æ£€æµ‹ï¼Œæ‰€ä»¥ç®€åŒ–å¤„ç†
                console.log('âœ… å‡è®¾æ¡¥æ¥è¿æ¥å¯ç”¨');
                return true;
            } catch (error) {
                console.warn('è¿æ¥æµ‹è¯•å¤±è´¥:', error);
                return false;
            }
        }

        function getBridgeStatusMessage(frontendStatus, backendStatus) {
            if (!frontendStatus.chrome_running) {
                return "Chromeæµè§ˆå™¨æœªè¿è¡Œ";
            } else if (!frontendStatus.extension_installed) {
                return "è¯·å®‰è£…MidSceneJS Chromeæ‰©å±•";
            } else if (!backendStatus.ai_configured && !frontendStatus.ai_configured) {
                return "è¯·é…ç½®AIæ¨¡å‹APIå¯†é’¥";
            } else {
                return "Chromeæ¡¥æ¥æ¨¡å¼å°±ç»ª";
            }
        }

        function updateBridgeStatusDisplay(status) {
            const contentEl = document.getElementById('bridgeStatusContent');
            const installBtn = document.getElementById('installGuideBtn');

            if (!contentEl) return;

            if (status.bridge_available) {
                contentEl.innerHTML = `
                    <div class="status-available">âœ… Chromeæ¡¥æ¥å·²å°±ç»ª</div>
                    <div>Chromeè¿è¡Œ: ${status.chrome_running ? 'âœ…' : 'âŒ'}</div>
                    <div>æ‰©å±•å®‰è£…: ${status.extension_installed ? 'âœ…' : 'âŒ'}</div>
                    <div>AIé…ç½®: ${status.ai_configured ? 'âœ…' : 'âŒ'}</div>
                    <div>è¿æ¥æµ‹è¯•: ${status.connection_test_passed ? 'âœ…' : 'âŒ'}</div>
                `;
                if (installBtn) installBtn.style.display = 'none';
                addLog('Chromeæ¡¥æ¥çŠ¶æ€æ£€æŸ¥å®Œæˆï¼šå·²å°±ç»ª', 'success');
            } else {
                contentEl.innerHTML = `
                    <div class="status-unavailable">âŒ ${status.message}</div>
                    <div>Chromeè¿è¡Œ: ${status.chrome_running ? 'âœ…' : 'âŒ'}</div>
                    <div>æ‰©å±•å®‰è£…: ${status.extension_installed ? 'âœ…' : 'âŒ'}</div>
                    <div>AIé…ç½®: ${status.ai_configured ? 'âœ…' : 'âŒ'}</div>
                    <div>è¿æ¥æµ‹è¯•: ${status.connection_test_passed ? 'âœ…' : 'âŒ'}</div>
                    ${status.error ? `<div style="color: #d73a49; font-size: 12px; margin-top: 4px;">é”™è¯¯è¯¦æƒ…: ${status.error}</div>` : ''}
                `;
                if (installBtn) installBtn.style.display = 'inline-block';
                addLog(`Chromeæ¡¥æ¥çŠ¶æ€æ£€æŸ¥å®Œæˆï¼š${status.message}`, 'warning');
            }
        }

        async function showInstallationGuide() {
            try {
                addLog('æ­£åœ¨è·å–å®‰è£…æŒ‡å—...', 'info');
                const response = await axios.get(`${API_BASE}/bridge/installation-guide`);
                if (response.data.code === 200) {
                    displayInstallationGuide(response.data.data);
                }
            } catch (error) {
                addLog('è·å–å®‰è£…æŒ‡å—å¤±è´¥', 'error');
            }
        }

        function displayInstallationGuide(guide) {
            // åˆ›å»ºæ¨¡æ€æ¡†æ˜¾ç¤ºå®‰è£…æŒ‡å—
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
                align-items: center; justify-content: center; padding: 20px;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                max-width: 800px; max-height: 80vh; overflow-y: auto;
                position: relative;
            `;

            let stepsHtml = guide.steps.map(step => `
                <div style="margin-bottom: 20px; padding: 15px; border: 1px solid #e1e4e8; border-radius: 6px;">
                    <h4>æ­¥éª¤ ${step.step}: ${step.title}</h4>
                    <p>${step.description}</p>
                    ${step.command ? `<code style="background: #f6f8fa; padding: 4px 8px; border-radius: 3px; display: block; margin: 8px 0;">${step.command}</code>` : ''}
                    ${step.commands ? step.commands.map(cmd => `<code style="background: #f6f8fa; padding: 4px 8px; border-radius: 3px; display: block; margin: 4px 0;">${cmd}</code>`).join('') : ''}
                    ${step.instructions ? `<ul>${step.instructions.map(inst => `<li>${inst}</li>`).join('')}</ul>` : ''}
                    ${step.config ? `<pre style="background: #f6f8fa; padding: 10px; border-radius: 3px; overflow-x: auto; font-size: 12px;">${JSON.stringify(step.config, null, 2)}</pre>` : ''}
                </div>
            `).join('');

            content.innerHTML = `
                <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 20px; cursor: pointer; color: #666;">Ã—</button>
                <h2 style="margin-top: 0;">${guide.title}</h2>
                ${stepsHtml}
                <h3>æ•…éšœæ’é™¤</h3>
                ${guide.troubleshooting.map(item => `
                    <div style="margin-bottom: 10px; padding: 10px; background: #fff3cd; border-radius: 4px;">
                        <strong>é—®é¢˜:</strong> ${item.problem}<br>
                        <strong>è§£å†³:</strong> ${item.solution}
                    </div>
                `).join('')}
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });

            addLog('å®‰è£…æŒ‡å—å·²æ˜¾ç¤º', 'success');
        }

        function toggleManualConfirmArea() {
            const area = document.getElementById('manualConfirmArea');
            if (area) {
                if (area.style.display === 'none') {
                    area.style.display = 'block';
                    addLog('æ˜¾ç¤ºæ‰‹åŠ¨ç¡®è®¤åŒºåŸŸ', 'info');
                } else {
                    area.style.display = 'none';
                }
            }
        }

        function applyManualConfirmation() {
            const confirmChrome = document.getElementById('confirmChrome').checked;
            const confirmExtension = document.getElementById('confirmExtension').checked;
            const confirmAI = document.getElementById('confirmAI').checked;

            const manualStatus = {
                chrome_running: confirmChrome,
                extension_installed: confirmExtension,
                ai_configured: confirmAI,
                connection_test_passed: confirmChrome && confirmExtension,
                bridge_available: confirmChrome && confirmExtension && confirmAI,
                message: getManualConfirmMessage(confirmChrome, confirmExtension, confirmAI),
                manual_confirmed: true
            };

            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('midscene_manual_status', JSON.stringify(manualStatus));

            updateBridgeStatusDisplay(manualStatus);

            // éšè—æ‰‹åŠ¨ç¡®è®¤åŒºåŸŸ
            document.getElementById('manualConfirmArea').style.display = 'none';

            addLog(`æ‰‹åŠ¨ç¡®è®¤å®Œæˆï¼š${manualStatus.message}`, manualStatus.bridge_available ? 'success' : 'warning');

            // å¦‚æœæ¡¥æ¥å¯ç”¨ï¼Œå¯ç”¨æ‰§è¡ŒæŒ‰é’®
            if (manualStatus.bridge_available) {
                const startBtn = document.getElementById('startBtn');
                if (startBtn) {
                    startBtn.disabled = false;
                }
            }
        }

        function getManualConfirmMessage(chrome, extension, ai) {
            if (!chrome) {
                return "è¯·å¯åŠ¨Chromeæµè§ˆå™¨";
            } else if (!extension) {
                return "è¯·å®‰è£…MidSceneJS Chromeæ‰©å±•";
            } else if (!ai) {
                return "è¯·åœ¨æ‰©å±•ä¸­é…ç½®AI APIå¯†é’¥";
            } else {
                return "æ‰‹åŠ¨ç¡®è®¤ï¼šChromeæ¡¥æ¥æ¨¡å¼å°±ç»ª";
            }
        }

        function loadManualConfirmation() {
            try {
                const saved = localStorage.getItem('midscene_manual_status');
                if (saved) {
                    const status = JSON.parse(saved);
                    if (status.manual_confirmed) {
                        addLog('åŠ è½½å·²ä¿å­˜çš„æ‰‹åŠ¨ç¡®è®¤çŠ¶æ€', 'info');
                        return status;
                    }
                }
            } catch (error) {
                console.warn('åŠ è½½æ‰‹åŠ¨ç¡®è®¤çŠ¶æ€å¤±è´¥:', error);
            }
            return null;
        }

    </script>
</body>
</html>
